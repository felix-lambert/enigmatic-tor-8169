{
  "name": "static-expiry",
  "version": "0.0.11",
  "description": "Connect middleware for static files that sets caching response headers as well as generates and rewrites fingerprinted urls.",
  "keywords": [
    "nodejs",
    "connect",
    "middleware",
    "static",
    "caching",
    "http",
    "fingerprint",
    "fingerprinting",
    "urls"
  ],
  "license": "MIT",
  "scripts": {
    "test": "make"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:paulwalker/connect-static-expiry.git"
  },
  "author": {
    "name": "Paul Walker"
  },
  "dependencies": {
    "fresh": "0.1.0",
    "findit": "0.1.2"
  },
  "devDependencies": {
    "should": "*",
    "mocha": "*"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.8.21"
  },
  "readme": "\n\n  static-expiry provides two things:\n\n  * A helper method `furl` for your templates in order to generate fingerprinted URLs for your static assets\n  * Middleware to handle incoming requests for the fingerprinted URLs.  It handles them by rewriting the url to it's original value and setting appropriate conditional/unconditional cache headers according to your configuration.\n\n*static-expiry* does not serve static assets.  It is invoked by calling it's function that returns the middleware.  It should be placed just before the middleware you use for serving static assets.\n\n**static-expiry** is meant to be everything you need to set up your app servers as origin servers to your CDN.  The two things it provides are key to this: versioned urls and handling the versioned urls.  Of course, you don't have to use a CDN and with **static-expiry** you are still serving static assets using best practices for caching.\n\n## static-expiry's cache\n*static-expiry* uses two lookup cache objects.  One that maps asset urls to the fingerprinted version, so that the function that generates fingerprinted urls only calculates once per asset.  And another that maps the incoming fingerprinted URL to an object that contains the unfingerprinted asset URL, the fingerprint (used for the etag header) and the file stat mtime (used for the last-modified header).  The latter is used by the middleware to rewrite the URL in the `req` object and set the appropriate cache headers.\n\n## Installation\n\n    $ npm install static-expiry\n\n## Quick Start\n\n```js\nvar express = require('express');\nvar app = express() // or just plain connect, there are no dependencies on express\n  , expiry = require('static-expiry');\n// ...\napp.use(expiry(app, { dir: path.join(__dirname, 'public') }));\napp.use(express.static(staticDir));\n// ...\napp.listen(3000);\n```\n\nThe function returned from the require statement takes two arguments, the first being the connect/express app (so that the app local can be set) and the second an object of options.\n\n## furl helper\nUse the `furl` app local in your templates in order to generate the fingerprinted URL.\n\n```html\n  <link rel=\"stylesheet\" href=\"{{ furl('/css/style.css') }}\" />\n  <!-- <link rel=\"stylesheet\" href=\"/css/a6edcf683bc4df33bb82ae1cca3cf21a-style.css\" /> -->\n\n  <link rel=\"stylesheet\" href=\"{{ furl('/css/style.css', '/css/style.min.css') }}\" />\n  <!-- <link rel=\"stylesheet\" href=\"/css/a6edcf683bc4df33bb82ae1cca3cf21a-style.min.css\" /> -->\n```\nThe second argument will be used when the NODE_ENV is not development.\n\n## Options\nThere are a number of options to control the fingerprinting and middleware.\n\n```js\napp.use(expiry(app, {\n```\noptions are passed in as the second argument\n\n### duration\nthe duration in seconds for the Cache-Control header, max-age value and the Expires header\n\n```js\nduration: 31556900, // defaults to 1 year\n```\n### unconditional\nwhat unconditional cache headers to set\n\n```js\n    unconditional: 'both' // default when process.env.NODE_ENV !== 'development'\n    /* \n    unconditional: 'max-age' // just set the Cache-Control header, max-age value\n    unconditional: 'expires' // just set Expires header\n    unconditional: 'none' // do not set either unconditional headers, default when in dev mode */\n```\n### conditional\nwhat conditional cache headers to set\n\n```js\n  conditional: 'both', // default when process.env.NODE_ENV !== 'development'\n  /*\n  conditional: 'last-modified' // only the Last-Modified header\n  conditional: 'etag' // only the ETag header\n  conditional: 'none' // neither the Last-Modfied or the ETag headers, default when in dev mode */\n```\n### cacheControl\nthe value of the Cache-Control header preceding the max-age value\n\n```js\n  cacheControl: 'cookieless', \n  // set to 'public' when there is no cookie present, 'private' if there is\n```\nany other string value is what will be used always, typically 'public' or 'private'.  use zero length, false, or null to not have a value.  the conditional option may still mean the Cache-Control header will be present however, e.g. `Cache-Control: max-age=31556900`\n\n### dir\nthe directory of the static assets\n\n```js\n  dir: path.join(process.env.PWD, 'public'),\n```\nI have no idea how reliable the presence of the PWD environment variable is, so it's probably best to set this\n\n### fingerprint\na function to use to generate the fingerprint\n\n```js\n  fingerprint: md5, // the default creates an md5 hash of the file contents\n```\nthe function takes the file path as it's only argument and should return the fingerprint value only (not the fingerprinted url)\n\n### location\nthe location of the fingerprint in the URL the `furl` function generates\n\n```js\n  location: 'prefile', // prefixes the filename of the asset with the fingerprint\n  /*\n  location: 'postfile' // postfixes the filename\n  location: 'query' // puts the fingerprint in a query string value with the name of 'v'\n  location: 'path' // prefixes the url with a directory with the name of the fingerprint value */\n```\nthe 'path' option could be problematic if you are using relative url references in your css/js files but could work if you supply your own function for generating the fingerprint value and make it static across all assets\n\n### host\na domain host value to be used for the fingerprinted URLs.\n\n```js  \n  host: null,\n  /* \n    host: 'cdn.acme.com'\n    // if you don't use a scheme a proto relative scheme will be used e.g. `\"//cdn2.acme.com/css/main.css\"`.\n    host: ['cd1.acme.com', 'https://cdn2.acme.com']\n  */\n```\nIf you use multiple hosts, the one selected is based upon a modulus of the sum of the character codes in the asset URL so that the same host is generated consistently across app servers.\n\nThis option is what you will use if setting up your app servers as origin servers to your CDN.  The fingerprinted URLs will then properly point to the CDN host(s) but your app servers can still serve the files with the caching strategy you have configured or defaulting to.\n\n### loadCache\nwhen to load the urlCache and assetCache\n\n```js\n  loadCache: 'startup' // loads the cache upon startup, the default in prod mode\n  // loadCache: 'furl' // loads the cache on an asset by asset basis when furl is invoked\n  // the default when not in prod mode\n  /* \n    loadCache: { at: 'startup', callback: function(file, stat) { /foo/.test(file); } }\n    you can pass an object in with a callback function in order to filter files\n    by name (file) or fs.Stats (stat).  this only works with the 'startup' mode.\n  */\n```\nthe 'startup' value is necessary in a multiple server environment as it is possible for a fingerprinted request to come into a particular server before it has generated a fingerprinted URL for that asset itself.  \n(i may work a way around this in the future, not too hard to reverse engineer the asset from the fingerprinted url)\n\n### debug\ncreate a GET /expiry route that outputs the json of the urlCache and assetCache\n\n```js\n  debug: process.env.NODE_ENV === 'development'\n}));\n```\n\n## Enabled vs Disabled (!development vs development)\nIf both conditional and unconditional have a value of none (the default in development), static-expiry is disabled and the `furl` function will not fingerprint the url.\n\n## TODO\n  * Handle file changes in a production mode either with a file watcher or dynamically looking at the file stats on every request.\n\n## Credits\n The inspiration for this project goes to bminer for https://github.com/bminer/node-static-asset\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2013 Paul Walker &lt;github@paulwalker.tv&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/paulwalker/connect-static-expiry/issues"
  },
  "_id": "static-expiry@0.0.11",
  "_from": "static-expiry@"
}
